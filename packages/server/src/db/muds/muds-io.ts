/*------------------------------------------------------------------------------
   About      : <Write about the file here>
   
   Created on : Mon May 21 2018
   Author     : Raghvendra Varma
   
   Copyright (c) 2018 Mubble Networks Private Limited. All rights reserved.
------------------------------------------------------------------------------*/
import * as Datastore                   from '@google-cloud/datastore'
import * as DsEntity                    from '@google-cloud/datastore/entity'
import { DatastoreTransaction }         from '@google-cloud/datastore/transaction'

import { Muds, DatastoreInt, 
         DatastoreKey }                 from './muds'
import { MudsBaseEntity }               from './muds-base-entity'
import { RunContextServer, DSTransaction }             from '../..'
import { MudsManager, MudsEntityInfo }  from './muds-manager';

/**
 * This is the main class on Muds system. All the Datastore operations should 
 * originate from here.
 * 
 * 
 * 
 * 
 * 
 * Useful Links:
 * Basics: https://cloud.google.com/datastore/docs/concepts/entities
 * Limits: https://cloud.google.com/datastore/docs/concepts/limits
 * Project: https://github.com/googleapis/nodejs-datastore/
 * Node docs: https://cloud.google.com/nodejs/docs/reference/datastore/1.4.x/ (notice version in the url)
 * 
 */
export abstract class MudsIo {

  protected datastore: Datastore
  readonly now: number

  constructor(protected rc: RunContextServer, 
              protected manager: MudsManager) {
    this.datastore = manager.getDatastore()
    this.now = Date.now()
  }

  /**
   * getExistingEntity: Call only when you just wish to read entity (no updates)
   * * Call this api when you are certain that entity exists in ds as it throws Muds.Error.RNF
   */
  async getExistingEntity<T extends MudsBaseEntity>(entityClass : Muds.IBaseEntity<T>, 
                 ...keys : (string | DatastoreInt)[]): Promise<T> {

    const entity = await this.getEntityIfExists(entityClass, ...keys)
    if (!entity) throw(Muds.Error.RNF)
    return entity
  }

  /**
   * getExistingEntity: Call only when you just wish to check presence and read entity (no updates)
   */
  async getEntityIfExists<T extends MudsBaseEntity>(entityClass : Muds.IBaseEntity<T>, 
                 ...keys : (string | DatastoreInt)[]): Promise<T | undefined> {

    const dsKey   = this.manager.prepareKeyForDs(this.rc, entityClass, keys),
          exec    = this.getExec(),
          [rec]   = await exec.get(dsKey)

    if (!rec) return undefined
    const key = (rec as any)[this.datastore.KEY] as DatastoreKey
    
    return new entityClass(this.rc, this.manager, 
      this.extractKeyFromDs(entityClass, key), rec as any)
  }

  /**
   * getForUpsert: Api to do insert or update on an entity
   * * Call this api to get editable entity either from ds or blank insertable copy
   * * This is just a convinience api (combination of getEntityIfExists -> getForInsert -> edit)
   */
  async getForUpsert<T extends Muds.BaseEntity>(entityClass : Muds.IBaseEntity<T>, 
                    ...keys : (string | DatastoreInt)[]): Promise<T> {
    let entity = await this.getEntityIfExists(entityClass, ...keys)
    if (!entity) entity = new entityClass(this.rc, this.manager, keys)
    entity.edit()
    return entity
  }

  /**
   * getForInsert: When you want to insert a new record in ds
   * * This would typically be with the key that will be generated by DS
   * * or sometimes when you are creating child of a parent like 'comment'
   */
  getForInsert<T extends MudsBaseEntity>(entityClass : Muds.IBaseEntity<T>, 
                ...keys : (string | DatastoreInt)[]): T {

    this.rc.isAssert() && this.rc.assert(this.rc.getName(this), keys.length)
    const entity = new entityClass(this.rc, this.manager, keys)
    entity.edit()
    return entity
  }

  enqueueForUpsert(...entities: MudsBaseEntity[]) {

  }

  async upsert(...entities: MudsBaseEntity[]) {

    const exec     = this.getExec(),
          dsRecs   = []

    for (const entity of entities) {

      this.rc.isAssert() && this.rc.assert(this.rc.getName(this), entity.isEditing(),
        `${entity.getLogId()} Skipping entity not in edit mode`)

      this.rc.isAssert() && this.rc.assert(this.rc.getName(this), entity.isModified(),
        `${entity.getLogId()} Skipping entity as it is not modified`)

      dsRecs.push(this.manager.getRecordForUpsert(this.rc, entity))
    }

    return await exec.upsert(dsRecs) as any
  }

  /* ---------------------------------------------------------------------------
    Abstract functions
  -----------------------------------------------------------------------------*/
  protected abstract getExec(): Datastore | DatastoreTransaction
  

  /* ---------------------------------------------------------------------------
   P R I V A T E    C O D E    S E C T I O N     B E L O W

   D O   N O T   A C C E S S   D I R E C T L Y
  -----------------------------------------------------------------------------*/
  protected extractKeyFromDs<T extends Muds.BaseEntity>(entityClass : Muds.IBaseEntity<T>, 
          key: DsEntity.DatastoreKey) : (string | DatastoreInt)[] {

    const entityInfo    = this.manager.getInfo(entityClass),
          ancestorsInfo = entityInfo.ancestors,
          arKey         = [] as (string | DatastoreInt)[]

    this.rc.isAssert() && this.rc.assert(this.rc.getName(this), 
      key.kind === entityInfo.entityName)
    this.rc.isAssert() && this.rc.assert(this.rc.getName(this), 
      entityInfo.keyType === Muds.Pk.String ? key.name : key.id)
    this.rc.isAssert() && this.rc.assert(this.rc.getName(this), 
      ancestorsInfo.length === (key.path.length / 2))

    for (let index = 0; index < key.path.length; index = index + 2) {
      const kind = key.path[index],
            subk = key.path[index + 1],
            anc  = ancestorsInfo[index / 2]

      this.rc.isAssert() && this.rc.assert(this.rc.getName(this), 
          kind === anc.entityName)
      if (anc.keyType === Muds.Pk.String) {
        this.rc.isAssert() && this.rc.assert(this.rc.getName(this), typeof(subk) === 'string')
        arKey.push(subk as string)
      } else if (typeof(subk) === 'string') {
        arKey.push(Muds.getIntKey(subk))
      } else {
        this.rc.isAssert() && this.rc.assert(this.rc.getName(this), typeof(subk) === 'object' && subk.value)
        arKey.push(subk as DatastoreInt)
      }
    }
    arKey.push(entityInfo.keyType === Muds.Pk.String ? key.name as string : 
      Muds.getIntKey(key.id as string))
    return arKey
  }
}

export class MudsDirectIo extends MudsIo {
  protected getExec(): Datastore | DatastoreTransaction {
    return this.datastore
  }
}

export class MudsTransaction extends MudsIo {

  private readonly transaction: DatastoreTransaction

  constructor(rc        : RunContextServer, 
              manager   : MudsManager, 
              private callback : (transaction: Muds.Transaction, now: number) => Promise<boolean>) {

    super(rc, manager)
    this.transaction = this.datastore.transaction()
    this.doCallback()
  }

  protected getExec(): Datastore | DatastoreTransaction {
    return this.transaction
  }

  private doCallback() {
    this.callback(this, this.now)
  }
}
