/*------------------------------------------------------------------------------
   About      : <Write about the file here>
   
   Created on : Mon May 21 2018
   Author     : Raghvendra Varma
   
   Copyright (c) 2018 Mubble Networks Private Limited. All rights reserved.
------------------------------------------------------------------------------*/
import * as Datastore                   from '@google-cloud/datastore'
import * as DsEntity                    from '@google-cloud/datastore/entity'
import { DatastoreTransaction }         from '@google-cloud/datastore/transaction'

import { Muds, DatastoreInt, 
         DatastoreKey }                 from './muds'
import { MudsBaseEntity }               from './muds-base-entity'
import { RunContextServer }             from '../..'
import { MudsManager, MudsEntityInfo }  from './muds-manager'

/**
 * This is the main class on Muds system. All the Datastore operations should 
 * originate from here.
 * 
 * 
 * 
 * 
 * 
 * Useful Links:
 * Basics: https://cloud.google.com/datastore/docs/concepts/entities
 * Limits: https://cloud.google.com/datastore/docs/concepts/limits
 * Project: https://github.com/googleapis/nodejs-datastore/
 * Node docs: https://cloud.google.com/nodejs/docs/reference/datastore/1.4.x/ (notice version in the url)
 * 
 */
export abstract class MudsIo {

  protected datastore: Datastore
  readonly now: number

  constructor(protected rc: RunContextServer, 
              protected manager: MudsManager) {
    this.datastore = manager.getDatastore()
    this.now = Date.now()
  }

  /**
   * getExistingEntity: Call only when you just wish to read entity (no updates)
   * * Call this api when you are certain that entity exists in ds as it throws Muds.Error.RNF
   */
  public async getExistingEntity<T extends MudsBaseEntity>(entityClass : Muds.IBaseEntity<T>, 
                 ...keys : (string | DatastoreInt)[]): Promise<T> {

    const [entity] = await this.getEntitiesInternal({entityClass, keys})
    if (!entity) throw(Muds.Error.RNF)
    return entity
  }

  /**
   * getExistingEntity: Call only when you just wish to check presence and read entity (no updates)
   */
  public async getEntityIfExists<T extends MudsBaseEntity>(entityClass : Muds.IBaseEntity<T>, 
                 ...keys : (string | DatastoreInt)[]): Promise<T | undefined> {

    const [entity] = await this.getEntitiesInternal({entityClass, keys})
    return entity
  }

  public getterQueue(): QueueBuilder {
    return new QueueBuilder()
  }

  public async getEntities(queueBuilder: QueueBuilder): Promise< (MudsBaseEntity | undefined)[]> {
    return await this.getEntitiesInternal(...queueBuilder.getAll())
  }

  private async getEntitiesInternal<T extends MudsBaseEntity>(
    ...reqs: GetEntityReq<T>[]): Promise< (T | undefined)[]> {

    const dsKeys  : DatastoreKey[] = [],
          arResp  : (T | undefined)[] = []

    for (const {entityClass, keys} of reqs) {
      dsKeys.push(this.manager.prepareKeyForDs(this.rc, entityClass, keys))
    }

    const exec      = this.getExec(),
          [results] = await exec.get(dsKeys)

    this.rc.isAssert() && this.rc.assert(this.rc.getName(this), results.length === reqs.length)
    for (const [index, result] of results.entries()) {
      if (!result) {
        arResp.push(undefined)
        continue
      }

      const {entityClass, keys} = reqs[index]
      console.log('result', result)

      if (this.rc.isDebug()) {
        const rawKeys    = (result as any)[this.datastore.KEY] as DatastoreKey
        const keysFromDs = this.extractKeyFromDs(entityClass, rawKeys)
        this.compareKeys(keys, keysFromDs) 
      }

      arResp.push(new entityClass(this.rc, this.manager, keys, result as any))
    }
    
    return arResp
  }
  

  /**
   * getForUpsert: Api to do insert or update on an entity
   * * Call this api to get editable entity either from ds or blank insertable copy
   * * This is just a convinience api (combination of getEntityIfExists -> getForInsert -> edit)
   */
  async getForUpsert<T extends Muds.BaseEntity>(entityClass : Muds.IBaseEntity<T>, 
                    ...keys : (string | DatastoreInt)[]): Promise<T> {
    let entity = await this.getEntityIfExists(entityClass, ...keys)
    if (!entity) entity = new entityClass(this.rc, this.manager, keys)
    entity.edit()
    return entity
  }

  /**
   * getForInsert: When you want to insert a new record in ds
   * * This would typically be with the key that will be generated by DS
   * * or sometimes when you are creating child of a parent like 'comment'
   */
  getForInsert<T extends MudsBaseEntity>(entityClass : Muds.IBaseEntity<T>, 
                ...keys : (string | DatastoreInt)[]): T {

    this.rc.isAssert() && this.rc.assert(this.rc.getName(this), keys.length)
    const entity = new entityClass(this.rc, this.manager, keys)
    entity.edit()
    return entity
  }

  enqueueForUpsert(...entities: MudsBaseEntity[]) {

  }

  async upsert(...entities: MudsBaseEntity[]) {

    const exec     = this.getExec(),
          dsRecs   = []

    for (const entity of entities) {

      this.rc.isAssert() && this.rc.assert(this.rc.getName(this), entity.isEditing(),
        `${entity.getLogId()} Skipping entity not in edit mode`)

      this.rc.isAssert() && this.rc.assert(this.rc.getName(this), entity.isModified(),
        `${entity.getLogId()} Skipping entity as it is not modified`)

      dsRecs.push(this.manager.getRecordForUpsert(this.rc, entity))
    }

    /**
     * [ { mutationResults: [ [Object] ], indexUpdates: 3 } ]
     * mutationResults [ { key: { path: [Array], partitionId: [Object] }, version: '1527613238307000', conflictDetected: false } ]
     * key { path: 
              [ { kind: 'User', id: '1', idType: 'id' },
                { kind: 'KeyType', id: '2', idType: 'id' },
                { kind: 'UserKeyValue', id: '5629499534213120', idType: 'id' } ],
             partitionId: { projectId: 'mubble-playground', namespaceId: '' } 
           }
     */

    const results = await exec.upsert(dsRecs)

    for (const [index, result] of results.entries()) {

      const entity           = entities[index],
            [mutationResult] = result.mutationResults

      this.rc.isAssert() && this.rc.assert(this.rc.getName(this), 
        !mutationResult.conflictDetected, `${entity.getLogId()} had conflict`)

      entity.commitUpsert(mutationResult.key ? mutationResult.key.path : null)
      
    }



  }

  /* ---------------------------------------------------------------------------
    Abstract functions
  -----------------------------------------------------------------------------*/
  protected abstract getExec(): Datastore | DatastoreTransaction
  

  /* ---------------------------------------------------------------------------
   P R I V A T E    C O D E    S E C T I O N     B E L O W

   D O   N O T   A C C E S S   D I R E C T L Y
  -----------------------------------------------------------------------------*/
  protected extractKeyFromDs<T extends Muds.BaseEntity>(entityClass : Muds.IBaseEntity<T>, 
          key: DsEntity.DatastoreKey) : (string | DatastoreInt)[] {

    const entityInfo    = this.manager.getInfo(entityClass),
          ancestorsInfo = entityInfo.ancestors,
          arKey         = [] as (string | DatastoreInt)[],
          keyPath       = key.path

    console.log('keyPath', keyPath)
    this.rc.isAssert() && this.rc.assert(this.rc.getName(this), 
      key.kind === entityInfo.entityName)
    this.rc.isAssert() && this.rc.assert(this.rc.getName(this), 
      entityInfo.keyType === Muds.Pk.String ? key.name : key.id)
    this.rc.isAssert() && this.rc.assert(this.rc.getName(this), 
      ancestorsInfo.length === (keyPath.length / 2) - 1)

    for (let index = 0; index < keyPath.length - 2; index = index + 2) {
      const kind = keyPath[index],
            subk = keyPath[index + 1],
            anc  = ancestorsInfo[index / 2]

      this.rc.isAssert() && this.rc.assert(this.rc.getName(this), 
          kind === anc.entityName)
      if (anc.keyType === Muds.Pk.String) {
        this.rc.isAssert() && this.rc.assert(this.rc.getName(this), typeof(subk) === 'string')
        arKey.push(subk as string)
      } else if (typeof(subk) === 'string') {
        arKey.push(Muds.getIntKey(subk))
      } else {
        this.rc.isAssert() && this.rc.assert(this.rc.getName(this), typeof(subk) === 'object' && subk.value)
        arKey.push(subk as DatastoreInt)
      }
    }
    arKey.push(entityInfo.keyType === Muds.Pk.String ? key.name as string : 
      Muds.getIntKey(key.id as string))
    return arKey
  }

  private compareKeys(keys: (string | DatastoreInt)[], keysFromDs: (string | DatastoreInt)[]) {

    this.rc.isAssert() && this.rc.assert(this.rc.getName(this), keys.length === keysFromDs.length)
    for (const [index, key] of keys.entries()) {
      const keyFromDs = keysFromDs[index]
      this.rc.isAssert() && this.rc.assert(this.rc.getName(this), key.constructor === keysFromDs.constructor)

      if (typeof key === 'object') {
        this.rc.isAssert() && this.rc.assert(this.rc.getName(this), (key as any).value === (keysFromDs as any).value)
      } else {
        this.rc.isAssert() && this.rc.assert(this.rc.getName(this), (key as any) === (keysFromDs as any))
      }
    }
  }
}

export class MudsDirectIo extends MudsIo {
  protected getExec(): Datastore | DatastoreTransaction {
    return this.datastore
  }
}

export class MudsTransaction extends MudsIo {

  private readonly transaction: DatastoreTransaction

  constructor(rc        : RunContextServer, 
              manager   : MudsManager, 
              private callback : (transaction: Muds.Transaction, now: number) => Promise<boolean>) {

    super(rc, manager)
    this.transaction = this.datastore.transaction()
    this.doCallback()
  }

  protected getExec(): Datastore | DatastoreTransaction {
    return this.transaction
  }

  private doCallback() {
    this.callback(this, this.now)
  }
}

export interface GetEntityReq<T extends MudsBaseEntity> {
  entityClass: Muds.IBaseEntity<T>
  keys: (string | DatastoreInt)[]
}

export class QueueBuilder {
  private arReq: GetEntityReq<any>[] = []
  add<T extends MudsBaseEntity>(entityClass : Muds.IBaseEntity<T>, 
    ...keys : (string | DatastoreInt)[]) {
    this.arReq.push({entityClass, keys})  
    return this
  }

  getAll() {
    return this.arReq
  }
}
