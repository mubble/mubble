package `in`.mubble.android.xmn

import `in`.mubble.android.core.MubbleLogger
import java.security.KeyFactory
import java.security.SecureRandom
import java.security.spec.X509EncodedKeySpec
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec


/*------------------------------------------------------------------------------
   About      : Router to manage communication with mubble servers

   Created on : 17/01/18
   Author     : Raghvendra Varma

   Copyright (c) 2018 Mubble Networks Private Limited. All rights reserved.

--------------------------------------------------------------------------------


TODO ????

------------------------------------------------------------------------------*/


class EncProviderAndroid(private val syncKey : ByteArray,
                         private val ci      : ConnectionInfo) : MubbleLogger {

  companion object {
    // not making these thread safe as these are used once at app load time
    private var initialized = false
    private val arShortCode: ByteArray = ByteArray(4)
    private val arUniqueId: ByteArray = ByteArray(3)

    fun init(ci : ConnectionInfo) {

      if (initialized) return

      initialized = true

      val regex = Regex("[a-zA-Z0-9]{1,4}")
      var index = 0

      // Populate the application's short code
      check(ci.shortName.matches(regex))
      for (char in ci.shortName) {
        arShortCode[index++] = char.toByte().minus(40).toByte()
      }

      // Populate the unique id (version number)
      index = 0
      var parts: List<Int> = ci.uniqueId.split('.').map {it.toInt()}
      if (parts.size > 1) {
        check(parts.size == 3 && parts[0] <= 99 && parts[1] <= 99 && parts[2] <= 99)
      } else {
        var num = parts[0]
        parts   = listOf(num / 10000, num % 10000 / 100 , num % 100)
      }

      for (part in parts) arUniqueId[index++] = part.toByte()
    }

  }

  private val ivSpec = IvParameterSpec(ByteArray(16))


  init {
    EncProviderAndroid.init(ci)

    // Generate random key for communication
    SecureRandom().nextBytes(ci.syncKey)
  }

  fun encodeHeader() {

    /*
      this.ci.syncKey: Sym key that is generated by client and then changed by server
      this.syncKey: Public key that is used to protect this.ci.syncKey
    */

    val encKey = ByteArray(1)




  }

  // 2 way encryption decryption
  // https://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA
  fun encryptDecrypt(inpBytes: ByteArray, decrypt: Boolean = false): ByteArray {
    val newKey = SecretKeySpec(ci.syncKey, "AES")
    val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
    cipher.init(if (decrypt) Cipher.DECRYPT_MODE else Cipher.ENCRYPT_MODE, newKey, ivSpec)
    return cipher.doFinal(inpBytes)
  }

  // Encryption of sym key using public key
  fun encryptKey(): ByteArray {
    val cipher = Cipher.getInstance("RSA/ECB/PKCS1PADDING")
    val pubKeySpec = X509EncodedKeySpec(syncKey)
    val fact = KeyFactory.getInstance("RSA", "BC")
    cipher.init(Cipher.ENCRYPT_MODE, fact.generatePublic(pubKeySpec))
    return cipher.doFinal(ci.syncKey)
  }



}